# **되도록 시간이 나면 주말에는 일주일에 배웠던 내용을 정리하여 나중에 면접 질문에 대비를 하기 위한 초석으로 마련하고자 한다**

![javasciprt](https://img.shields.io/badge/javascript-up%20to%20date-yellow)

![typescript](https://img.shields.io/badge/typescript-up%20to%20date-blue)

---

## 객체 지향 프로그래밍

1. 객체 지향에서의 기본 모토는 하나의 블록 내부에 state와 method가 존재하고, 이를 기능단위로 나누는 프로그래밍 방식이다

2. 객체 지향 프로그래밍의 4대원칙
   > a, 캡슐화(데이터와 기능을 한곳에 묶는 것. 또한 이 내부의 상태는 내부의 메소드를 이용해서만 변경할 수 있는 것을 통해 은닉화를 가능하게 한다. </br> 또한, 각 메소드는 각자의 기능을 담당하고 서로가 서로의 내부작동에 대해 크게 관여를 하지 않으므로 느슨한 결합을 이루는 데에도 도움이 된다. </br>반대로 고도의 결합은 한 함수가 다른 함수의 내부적인 코드를 잘 알고, 연결되고, 영향을 미칠 수 있는 상태를 말하며 이러한 결합은 최대한 피해야 한다. 왜냐하면 한 함수에서 문제가 발생할 경우, 다른 함수에도 연쇄적으로 문제가 파생될 가능성이 아주 높아지기 때문이다)

> b. 추상화(내부의 복잡성을 다 나타내기 보다, 해당 기능적 요소에 초점을 맞추고 이에 대한 내용만을 노출하는 방식. 이는 객체지향 프로그래밍에서 상태를 변경하기 위한 메소드만을 제한적으로 노출할 수 있다는 점에서 설명이 가능한 부분이다)

> c. 상속(부모 클래스의 특성을 자식 특성이 이어받는것) 즉, 공통적으로 사용할 상태나, 메소드등을 prototype을 이용하여 공유하는 시스템을 사용한다.

> d, 다형성(똑같은 메소드를 상속받아 왔을지라도, 그 내부의 환경에 따라서 하는 행동이 달라지도록 메소드를 제작하는 방식을 말한다. 예를들어, 부모에 render 이라는 메소드가 있고, 이 메소드를 통해 전달되는 인자에 따라서 렌더되는 결과가 달라지는 형태로 제작하는 것을 의미한다.)

## 프로토타입

자바스크립트는 프로토타입 기반 언어로, 이 프로토타입을 이용한 상속을 통해 인스턴스를 생성함으로 재사용성을 추구하는 개발을 할 수 있다.

자바스크립트는 es6로 올라오면서 class와 같은 객체 인스턴스 생성 문법을 도입하였고, 이것을 통해 타 언어에 존재하던 private, protected, public 등을 이용한 객체 지향적 개발을 흉내낼 수 있게 되었다.

자바스크립트의 모든 객체는 [[prototype]] 이라는 내부 슬롯을 가진다.

이 슬롯 내용물은 객체의 생성 방식에 따라 달라진다.

예를 들어, 객체 리터럴로 생성한 객체 {} 의 프로토타입슬롯 내부에는 Object.prototype 이라는 원시 Object 빌트인 객체에서 물려받은 prototype property 정보를 나타낸다. 만약 함수 생성자를 통해서 만든 인스턴스라믄 프로토타입 슬롯 내부에는 생성자 함수가 가지고 있던 내부의 "prototype" 이라는 프로퍼티가 바인딩되게 된다.</br> </br> 즉 어떻게 되든 생선된 객체가 가지고 있는 prototype 슬롯의 내부내용 바인딩은 Object built in 객체든, 일반 생성자 함수든 상관없이 그 안의 prototype 프로퍼티를 물려받는다고 보는 것이 타당하다.(왜냐하면 함수 역시 객체이기 떄문이다)
하지만 여기서 주의할 것이, 생성된 객체가 그렇다면 prototype이라는 프로퍼티를 갖고 있느냐고 물어본다면 그것은 거짓이다. 객체는 내부의 prototype 슬롯에 Object 빌트인 객체가 가지고 있는 prototype 프로퍼티를 바인딩한 상태인 것이고,생성자 함수는 마치 Object 빌트인 객체와 비슷한 역할처럼 그 자신이 객체로서 자신을 통해 만들어지는 인스턴스들의 prototype 슬롯에 자신이 갖고 있던 prototype 프로퍼티를 전달하는 역할을 하는 것이다.
.</br> 모든 프로토타입 객체의 내부에는 자신을 생성한 대상이 누군지를 나타내주는 constructor라는 프로퍼티가 존재한다. 이것을 통해 자신을 만들어낸 대상이 누군지를 확인할 수 있다.

객체의 프로토타입 슬롯에 접근하기 위해선 접근자 프로퍼티인 "\_\_proto**" 를 사용하는 것이 일반적이었다(내부에 get,set이라는 메소드를 이용하여 프로토타입과 관계를 맺는다. 마치 class의 extends와 같다. 만약 어떤 객체를 \_\_proto** 로 연결하여 obj.\_\_proto\_\_ = parent 객체로 지정한다면, 이것은 마치 class에서 부모객체를 extends하여 내부에서 super함수를 이용해 상속받는것과 비슷한 역할을 한다.)

이러한 이상한 방식의 간접적인 접근자 함수로서의 접근방식이 필요한 이유는, 상호 참조로 인한 무한루프를 방지하기 위함이다. 예를 들어, 자식객체가 부모객체를 프로토타입으로서 연결했다고 가정하고, 부모객체가 자식객체를 프로토타입으로 연결했다 가정하면 서로가 서로를 프로토타입으로서 참조하는 이상한 관계가 형성되게 되며, 자바스크립트 엔진이 만약 해당 객체에서 필요하는 프로퍼티를 찾지 못하여 \_\_proto\_\_ 로서 부모에게 상속받은 메소드나 상태를 확인하려고 하는 경우 문제가 발생하게 된다. </br> 이를 방지하기 위해 생겨난 방식이지만 요 근래에는 이 프로토 접근자 프로퍼티를 직접 사용하는것을 권장하지 않는 편이다.(왜냐면 Object 빌트인 객체 안에 있는 create 메소드로 만들어지는 객체는 Object 안에 있는 prototype 프로퍼티를 상속받지 않는 것과 같은 케이스가 나올 수 있기 때문에)</br> 따라서 대신에 Object 빌트인 객체의 안에 있는 메소드 중에 하나인 getPrototypeOf(),setPrototypeOf()를 이용하는 것이 현명하다.
