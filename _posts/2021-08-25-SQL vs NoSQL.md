# **관계형과 비 관계형의 차이**

![javasciprt](https://img.shields.io/badge/javascript-up%20to%20date-yellow)

![typescript](https://img.shields.io/badge/typescript-up%20to%20date-blue)

---

# SQL

- 정해진 주제에 따른 테이블이 있다
- 그 주제는 스키마를 통해서 구현되어 있다
- 관계를 통해(join) 여러 테이블이 분산이 된다.

데이터는 테이블에 따라 명확하게 정해진 구조가 있고, 해당 구조를 따르지 않는 데이터는 넣을 수가 없다.

또한, 개발자도 사람인지라 특정 테이블에 존재하는 어떤 데이터가 다른 테이블에도 중복해서 존재하지 않으리라는 보장이 없다.
이런 중복을 해결하기 위해 "관계" 라고 하는 방식을 이용하는데

예를들어, _User_ 라는 테이블의 안에 id가 존재하고, _Products_ 라는 테이블 안에 존재하는데, _Order_ 테이블에 해당 데이터가 존재한다면 유저 테이블에서 id를, 프러덕트 테이블에서 id를 가져와서 합치는 형식으로, 즉 어찌보면 참조하는 형식으로 데이터를 구성한다는 것이다.

이것의 장점은 만약 어느 한 데이터가 바뀌면 다른 데이터도 바뀌어서 동일성을 유지할 수 있다는 것을 확신할 수 있다는 것이다. 이는 다시말하면 동일성에 대한 안정성을 확보하고 있으므로, 자유롭게 데이터를 수정하는데 용이하다는 장점이 있다.

```
단점 : SQL은 데이터 저장의 특성상, 특정 테이블에 존재하는 데이터가 다른 데이터에 존재하지 못한다는 형태, 즉 중복이 발생하면 안된다는 형태를 가지고 있다.

이에 따라서 만약 자료의 수가 많아지는 경우, 확장성에 있어서 유일한 방법은 데이터베이스가 있는 컴퓨터의 성능을 향상시키는(ex CPU를 업그레이드하여 검색 관련 처리 계산을 빠르게 한다든가, 메모리를 증가시켜 공간을 늘린다든가) 하는 방식의 확장성만 가능하다. (수직적 스케일링)

즉, 확장에 있어서 어느 순간이 되면 한계가 존재한다.
```

# NoSQL

반대로, 비관계성은 그 의미대로 이해하면 좋다.
SQL과 반대로, NoSQL은 특별하게 정해진 스키마가 없다.
(다만 MongoDB와 같은 데이터베이스 솔루션은 자신의 내장으로 스키마가 존재한다. 이 스키마대로만 데이터를 저장할 수 있다는 장점은 있지만, NoSQL의 한계와도 같은, 다른 장소에 저장된 데이터의 중복을 가려내지는 못한다는 문제는 있다)

NoSQL은 특별한 스키마가 존재하지 않기 때문에, 어떤 형식으로든 데이터를 넣을 수 있다.

구조는 SQL의 테이블과는 유사하면서도 다른 형태를 띄고 있다

일단 가장 큰 집합의 형태를 collection 이라고 부르며,
그 collection에 저장된 데이터를 Document라고 칭한다.
이 도큐먼트는 Json과 유사한, 오히려 객체와 유사한 형태로 저장이 되어있다

예를들면, User 콜렉션에 {name:"h", age:2} 와 같은 꼴로 저장되 있는 것을 뜻한다.

또한 딱히 스키마가 존재하지 않기 때문에, 그냥 User라는 큰 콜렉션 타이틀 아래에서 관계가 있어보이는 데이터를 자유롭게 저장할 수 있다는 장점과, 만약 데이터가 많아져서 확장을 해야하는 경우, 수직적 스케일링밖에 가능하지 않은 SQL에 비해, 그냥 얘는 아무곳이나 다른 컴퓨터를 가져와서 거기다가 새롭게 데이터를 추가하면 되는, 즉 수평적인 스케일링이 가능하므로 확장이 자유롭다는 장점도 있다

```
단점 : 하지만 저 자유가 단점이다. 콜렉션 안에 자유롭게 데이터를 관계하도록 넣을 수 있다는 장점때문에, 만약 데이터가 중복되는 경우가 존재한다면 어느 하나를 바꿀 때 도큐먼트 전체를 다 둘러봐서 수정해야 하는 경우가 생긴다. MongoDB 처럼 스키마를 도입해서 콜렉션에 넣을 수 있는 데이터의 형태를 정해놨다고 하더라도, 다른 콜렉션에서 중복적인 스키마를 설정하여 데이터를 저장하는 것은 막을 수가 없다.
```

# 그렇다면 언제 SQL? NoSQL

SQL => 데이터가 빈번하게 변경이 되야하는 자료형이라면 사용하자
NoSQL => 확실하게 스키마를 설정할 수 있고, 데이터의 변화가 적다면 사용하자.
