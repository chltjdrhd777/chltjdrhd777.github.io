# **prototype은 언제 생성되는 것일까**

![javasciprt](https://img.shields.io/badge/javascript-up%20to%20date-yellow)

![typescript](https://img.shields.io/badge/typescript-up%20to%20date-blue)

---

예를들어,

함수가 존재한다고 치자.

이 함수가 전역에 존재한다고 가정하면, 우선 ECMAscript의 기준에 따라 자바스크립트 엔진이 js 파일을 읽어내리기 시작한다.

그 때에 전역 객체가 형성이 되고, `예를들어 Window {}`
이 객체의 안에 기본 빌트인 객체인 Object,Array,Boolean 등이 들어간다. 참고로 window 객체 역시 이미 만들어지는 시점에서 prototype 슬롯에 Object.prototype이 들어가있는 상태다.

그리고 이 윈도우 객체에는 각종 webAPI 와 관련된 프로퍼티들 (예를들어 console, fetch, httpXmlRequest, web storage) 와 같은 존재들이 들어가있고, browser을 컨트롤하기위한 객체인 BOM, document를 컨트롤하기위한 DOM 와 같은 것들이 들어가 있다.

이 거대한 객체의 형성 후, 자바스크립트를 쭉 읽어가면서 전역 변수, 전역 함수의 식별자를 키로 지정하여 넣고 런타임에 할당문이나 함수객체 생성을 하여 바인딩함으로서 *전역 실행 컨텍스트*를 형성한다.
이 만들어진 전역 실행 컨텍스트가 자바스크립트의 실행 스텍에 쌓이게 된다.

만약 실행 컨텍스트 안에 함수가 존재하였고, 이 함수가 평가된 후 런타임에 실행이 된다면 실행의 포커스는 이제 함수로 집중되게 된다.
따라서 함수 컨텍스트를 형성한 후, 전역 컨텍스트가 해왔던 것처럼 변수의 선언(여기에는 매개변수의 선언을 포함한다), 함수 식별자의 선언, this의 결정(보통은 strict mode에서 undefined), 그리고 제일 중요한 스코프 슬롯을 형성하여 그 안에 유사배열 형태로 스코프를 정의한다.

이게 무슨 말이냐면, 함수가 실행되기 전, 즉 런타임 전에 함수가 객체로서 평가를 받는 그 순간에 이미 prototype이라는 암묵적인 프로퍼티가 형성이되고, 그 안에서 내부 메소드들을 정의한 후, scope 슬롯에 자신의 렉시컬한 스코프들을 정의하고 있다는 소리다.

이것은 내부 메소드들도 다를바가 없어서, 안에서 prototype의 안으로 정의되면서 이미 그 식별자를 만들고 함수 객체로서 평가를 받을 때에 이미 또다시 prototype을 형성하고 자신의 스코프 슬롯에 정의를 떄려박는다. 이때에 스코프 슬롯은 만약 상위가 함수가 아니라면, 즉 지금처럼 prototype 프로퍼티라서 이것은 객체고 함수가 아니라면 그것보다 상위에 있는 범위, 즉 Tree 클래스(이자 함수) 인 자의 스코프가 정의하고 있는 것을 따른다.

따라서 해당의 내용이 가능해진다

```js
class Tree {
  constructor(name) {
    this.name = name;
  }

  method() {
    let test = new Tree("hello");
  }
}

const testing = new Tree("hi");
// 저기에서 method가 new로 Tree를 호출하고있다.
// 우선 진행과정은 식별자를 "스코프"를 따라 찾는것부터 시작하는데,
// 다시금 말하지만 Tree는 클래스이지만 결국 함수고, 함수객체가 평가가 되는 순간 이미 scope와 prototype 프로퍼티는 정해져있다. prototype이 정의되는 순간 그 안에 method도 정해지고, 내부 프로토타입 슬롯에는 Object.prototype이 전달되게 되는 상황인데
// 이 method가 전달되는 과정에서 해당 method의 식별자와 함수객체가 평가가 된다. 평가가 된다는 소리는 내부에 암묵적인 prototype 프로퍼티와 함께 "스코프" 가 설정이된다는 뜻이다.

//아까 위에서 설명했듯, 스코프를 형성함에 있어서 자신의 상위에서 찾을 수 없다면 가장 먼저 만나게되는 상위의 컨텍스트가 정의하고 있는 스코프를 따르므로, method는 Tree 의 스코프를 따르게 된다. 따라서 method 내부에서 new로 Tree를 할때에 Tree 식별자를 어디서 찾지? 하는 고민은 해결된다. 왜냐하면 스코프에 이미 Tree 라는 식별자가 정의된 스코프가 존재하기 때문에다. 스코프 체인에 따라 해당 식별자를 찾기까지 나간 후, 그것을 이용하여 객체를 형성하고 있다.
```
