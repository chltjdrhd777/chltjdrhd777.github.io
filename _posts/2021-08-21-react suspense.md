# ** 로딩을 아름답게 처리하기 위한 노력**

![javasciprt](https://img.shields.io/badge/javascript-up%20to%20date-yellow)

![typescript](https://img.shields.io/badge/typescript-up%20to%20date-blue)

---

# 생각의 계기

평소 리엑트로 로딩을 구현하다가 보면 생각나는 부분이 있다.

> 아니 3항연산자로 그래, 조건부 로딩을 렌더링하는건 아름답긴 해. 근데, 지저분하지않아?

이런 생각을 하게 될 수밖에 없는게, 만약 redux로 loding 관련 디스패치까지 생각하게 된다면
생각보다 코드가 상당히 지저분해진다. 거기에 더해서 어떤 사람은 로딩을 지역적으로 상태관리하여 쓰고싶어하는 사람도 있을건데 그러면 지저분의 지저분을 더해 지저분의 끝을 달린다.(물론 그렇게까지 지저분하게 만들 사람은 없겠지만)

```js
  //ex
  const [loading, setLoading] = useState(false);
  const Loading = LOADING;

  dispatch({type:Loading, payload:loading});

  .
  .
  .
  return (
    <div>
      {loading ? (<Component1>) : (<Component2/>)}
    </div>
  )
  //겨우 로딩 하나때문에 이렇게 너저분해지는건 솔직히 별로라고 생각한다
```

그래서 그 고민에 대해서 늘 가지고있다가, 리엑트 공식문서를 보다보니 해결점이 하나 보인다
(공식문서를 안본 나를 탓하자)

보통 로딩이 발생하게 되는 상황은, 페이지간의 이동이 일어나는 데에 따른 대기시간이 관건일것이다.
어떠한 컴포넌트가 무언가 데이터를 받아와서 상당히 오래걸린다면, 그 랜더링을 기다려주기 위한 로딩 컴포넌트를 띄워줘야 하는데, 그것을 삼항 연산자로 하고 있었다면 리엑트 팀은 조금 더 스마트한 방법을 제시한다.

그것은 바로 "코드의 분할" 이라는 관점이다.

컴포넌트들을 모듈처럼 따로따로 각각 저장하여 import로 가져오는 것은 매우 아름답고 좋다. 그런데 가끔 컴포넌트들이 너무 비대해질 경우 (예를 들어, route 관련한 내용을 살펴보면 각각의 route에 대해 수십,수백가지의 component들의 갈래들이 존재하고, 그것들을 다 임포트해서 사용한다면 번들링 과정에서 그 크기가 비대해질수밖에 없다.)

웹펙이 번들링하는 과정에서 그 부담도가 상당히 커질 수밖에 없다.

그래서 리엑트 팀이 생각한 것은 바로 "동적인 import" 이다.
이것을 이해하기 위해선 일단 코드분할에 대한 걸 먼저 봐야하는데, 대략적으로 webpack에 설명하고 있는 내용들을 보면이렇다

0. 웹펙 설정에서 entry 포인트는 그냥 하나의 index로 퉁치지 말고, 각각의 모듈에 대해서 각각의 엔트리 포인트를 설정해준다. 또한 output 옵션에도 각각의 이름대로의 번들을 만들도록 설정한다. (ex index.bundle.js, another.bundle.js)
1. 코드를 번들링 할 때, 특수한 옵션을 줘서 분할된 각각의 파일 들 가운데 중복되는 Import를 배제하도록 한다 (각각의 엔트리 포인트에서 dependOn 프로퍼티로 shared를 설정하고, 엔트리의 프로퍼티에 shared 되는 임포트 모듈을 설정해주는것도 좋긴한데, 너무 많아지면 복잡하니까 그냥 한번에 optimization 프로퍼티에 runtimeChunk single을 줘서 중복을 방지한다)

2. 동적 임포트를 사용한다. 여기서 반대개념인 정적임포트가 바로 원래 사용하던 import from 인데, 이것은 각 독립적인 모듈이 export하는 모듈객체를 복사하여 가져오는, 말 그대로 그냥 정해져있는 내용물을 그대로 들고오는 행동이다. 동적 임포트는 특정 모듈을 임포트해온 후, 그것을 프로미스 객체에 감싼 뒤에 리턴하는 방식을 취한다. 즉, 다시말하자면 임포트와 그 이후의 작업을 비동기적으로 수행할 수 있다는 뜻이 된다.

비동기적인 임포트의 수행과 그 이후의 작업행동 덕택에, 웹펙이 번들을 하는 과정에서 너무 큰 컴포넌트의 번들 과정을 조금 더 부담되지 않게 수행할 수 있는 장점이 존재한다.

다시 원래대로 돌아가서,

react는 그래서 이런 비동기적인 동적 임포트와 그 비동기적인 수행이 일어나기 전 fallback으로 보여줄 로딩화면에 대한 suspense 컴포넌트를 각 라우트가 이동하는 과정에서 사용하는 방향으로 이용하는 것을 제시해준다.

```jsx
import React, { Suspense, lazy } from "react";
import { BrowserRouter as Router, Route, Switch } from "react-router-dom";

const Home = lazy(() => import("./routes/Home"));
const About = lazy(() => import("./routes/About"));

const App = () => (
  <Router>
    <Suspense fallback={<div>Loading...</div>}>
      <Switch>
        <Route exact path="/" component={Home} />
        <Route path="/about" component={About} />
      </Switch>
    </Suspense>
  </Router>
);
```

위 내용을 보면, 기본적으로 필요한 Import는 정적으로 가져오는데, 각각의 route에 대해서는 동적 import를 통해 프로미스 객체를 받아와서 그것을 lazy 메소드를 이용하여 컴포넌트 객체로 다시 리턴하는 형태를 보여준다.

즉 해당 코드가 적힌 파일이 읽힌다면 우선,

1. import를 통해 필요한 모듈들을 가져온다(lazy 메소드는 이미 가져오면서 평가와 함수객체 형성이 되어있다.)
2. 식별자를 이용한 상수들을 선언한다
3. 런타임에 할당문이 실행되면서 뒤에 있는 내용물들이 실행된다.
4. 이 때에 lazy 메소드가 호출이 되면서, 콜백으로 화살표 함수를 받는데 이 화살표 함수의 평가가 이루어진 후 실행을 하게되면 모듈을 받아와 프로미스 객체화하여 내보내는 작업을 한다. 즉, 비동기적인 실행을 하므로 작업공간에 저장되어 있다가 처리가 끝나는 순대로 event queue에 들어가서 콜스텍이 빌 때마다 기회를 틈타 넣어주는 상황이다. 그 처리가 끝나면 Homer과 About에 각각의 컴포넌트가 들어가게 된다.

그 후 app쪽의 할당문이 실행이 되면서 화살표 함수객체가 평가되며 들어가고, 이것이 export되어 index에서 사용되는 상황이 되면, 만약 그것이 Home 컴포넌트가 보여줘야 될 상황에 아직 비동기적인 처리가 끝나지 않았다면 Suspense가 이를 감지하고 fallback에 들어있는 컴포넌트 객체를 랜더링하여 화면에 보여주는 구조다.

즉, 동적인 임포트를 통해서 로딩을 저렇게 구현했고 라우팅에 따른 로딩을 저렇게 한방에 간단하게 설정할 수 있게 되었다. 앞으로 자주 응용해야겠다.
