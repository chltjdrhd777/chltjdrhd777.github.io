# **똥같은 syntheticEvent**

![javasciprt](https://img.shields.io/badge/javascript-up%20to%20date-yellow)

![typescript](https://img.shields.io/badge/typescript-up%20to%20date-blue)

---

사건의 계기는 이러하다.

나는 정말로 간단한, 컴포넌트 외부를 누르면 document에 심어놓은 이벤트 리스너를 지우는 행위를 하고 싶었다.

그런데, 이놈의 이벤트 버블링때문에 버튼을 클릭했더니 document에 걸려있던 이벤트도 같이 실행되는 것이 아닌가.

정확하게 말하면, 컴포넌트 외부에 document.addEventListener을 해주는 온클릭 함수가 있는 컴포넌트가 존재했는데

이시키도 역시 외부 컴포넌트로 인식되다보니, 클릭직후 버블링이 실행되면서 document에 걸린 이벤트도 실행되버리는 것이다.

그래서 정말 별의 별 짓을 다해봤다

0. 해당 버블링을 일으킬 것 같은 버튼에 react의 ref를 걸어두고, 현재 누르는것과 current가 같지 않으면 document에 걸린 함수는 아무것도 하지 않도록 하기

   > 구현은 된다. 근데 매번 모든 이벤트에다가 다 ref를 걸어주기도 너무 힘들어서 일단은 이렇게 구현해두고 다른방법을 찾았다

1. addEventListner의 세번째 옵션인 캡쳐링 사용

   > 부모인 document의 listner 등록시에 캡쳐링을 하면, 이벤트 페이즈에서 첫 단계에서 그냥 실행되는 것일 뿐이었으므로 내가 원하는 결과를 얻지는 못했다

2. addEventListner의 once옵션 사용

   > 실행이 한번만 되고 리스너에서 삭제되게 하는 옵션인데, 문제는 그 버튼 자체에 다시 listner을 추가하는 행동을 하고있어가지고 실행은 실행대로 하고 리스너는 또 등록되는 일이 벌어진다

3. target과 currentTarget을 사용

   > target은 현재 클릭 이벤트가 발생한 노드타겟, 그리고 currentTarget은 캡쳐링이벤트와 버블링 이벤트때와 같이 현재 클릭된 이벤트가 아닌 전파되면서 현재진행형중에 전파된 노드의 객체를 의미한다. 전파를 막지 못하니, 저 옵션은 아무런 도움이 안됬다.

4. e.stopPropagation으로 버블링 막기
   > 아니 분명히 설명대로면 버블링을 해당 버튼에서 막으니까 document에 전파는 안되야 하는거 아냐? 하고 생각했으나 아주 하찮은 생각이었다.

그런데 3번째까지 와서 보니까, 도대체 왜 e.stopPropagation은 버블링을 못막지? 버블링 막으라고 있는 메소드아냐? 뭐하는짓이야 저게. 하는 분노와 함께 도대체 이벤트가 어떻게 실행되는지를 파보게 되었고, 결론을 도출할 수 있었다.

우선 native 자바스크립트에서는 이벤트가 발생하면 브라우저의 window 객체는 내장하고 있는 event 생성자 함수로부터 Event 객체를 만들고, 해당 이벤에 필요한 정보들을 담아서 전파를 시작한다.

그때에 크게 3개의 페이즈로 나뉘어서 전달되는데

1. 캡쳐링 페이즈 => 윈도우부터 쭉 내려오면서 타겟 대상까지 전부 다 캡쳐링되며 이벤트를 인식한다. 일반적으로 이벤트 객체가 만들어질 때, 캡쳐링 옵션이 true가 아니라면 이 페이즈에서는 아무것도 하지 않는다. 캡쳐링이 트루면 이 때에 만약 해당 이벤트와 관련된 핸들러가 노드객체에 이벤트 리스너에 들어가 있다면 실행되고 끝난다.

2. 이벤트 타겟 페이즈 => 해당 이벤트 타겟에 도착한 페이즈. 이 때에 타겟페이즈는 두가지를 다 인식하는데 첫째는 본인 스스로가 캡쳐링이 되는 페이즈의 인식, 그리고 버블링 단계에 진입하면서 실행되는 버블링페이즈. 즉, 만약 캡쳐링 옵션이 트루면 해당 타겟에서 두번 이벤트가 발생한다.

3. 버블링페이즈 => 다시 타겟 기준 부모로 올라가면서 이벤트 객체가 전달되면서 이벤트 핸들러가 실행된다.

도대체 왜 저딴식으로 만들어놨는지는 모르겠지만, 일단 저렇게 이벤트가 전파가 되고, 만약 이 행위를 막고 싶다면 e.stopPropagation()을 사용하면 해당 노드를 기준으로 이벤트 전파 페이즈가 진행되지 않는다.

그런데, 문제는 저 e.stopPropagation이 자바스크립트의 것과, 리엑트의 것이 다르다는 것이다.(이게 제일 분노를 일으키는 부분이었다)

리엑트팀은 자바스크립트에 어떤건 버블링이 되고 안되고 하는 혼란을 일축하기 위해 모든 이벤트는 기본적으로 버블링이 true로 만들고, syntheticEvent라는 자신들만의 이벤트 객체를 리엑트 돔에서 만들어서 이벤트 페이즈를 진행한다

이 syntheticEvent 객체는 또 하는짓이 골때리는게, 원래 이벤트 객체의 버블링 트리를 참조해서 이벤트 타겟의 프로퍼티들에 등록되어 있는 애들을 전부 dispatch를 통해 모아서 하나의 큐로 만든다.

참고로, 순수 자바스크립트에서 이벤트핸들러를 등록하는 방법은 크게 2가지다

1. addEventListner로 내부적으로 주입하는 방식
2. onclick 프로퍼티에 주입하는 방식

둘 다 이벤트를 실행하는 방식은 같은데, 문제는 둘은 엄연히 말해서 다른 영역이라는 점이다. 즉, 만약에 한 노드객체에다가 addEventlistner과 onclick을 둘 다 넣는다면 이벤트 발생시 둘 다 호출된다.

리엑트팀은 이런 혼란을 막기 위해 오히려 addEventListner과 관련된 행위는 모르겠고 난 프로퍼티 형태로 주입된 이벤트만 메소드로 관리하겠다. 라는 느낌이 아주아주아주 강하다.

결론적으로 말해서, 리엑트에서 e.stopPropgation을 호출하면 onClick에 들어가있어서 큐에 삽입되었던 그 큐에서 뒤에부분이 스탑되는 행위를 한다.

즉, 만약에 해당 전파가 해당 큐와 관련없는, 즉 나와같이 document.addEventLisnter로 등록된 이벤트였다면 전파는 막지 못한다.

따라서, 나는 이 문제를 해결하기 위해 결국 document에 addEventListner로 심어두었던 이벤트 핸들러를 프로퍼티 형태로 넣어보았고, 그러자 원하는대로 이벤트가 버블링 전파가 막아지는 것을 확인할 수 있었다.

> 덕택에 이벤트에 대해서 좀 더 알게 되긴 했지만 정말 화가난다....
