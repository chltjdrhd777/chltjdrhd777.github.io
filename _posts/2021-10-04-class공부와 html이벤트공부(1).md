# **코어 자바스크립트 공부내용 정리**

![javasciprt](https://img.shields.io/badge/javascript-up%20to%20date-yellow)

![typescript](https://img.shields.io/badge/typescript-up%20to%20date-blue)

---

# class

자바스크립트의 클래스는 일반적으로 public하다
이 말인즉슨, 인스턴스화 시키면 외부에서 접근이 자유롭다는 뜻이다.

타입스크립트를 이용하면 readonly나 private과 같은 키워드를 통해서 자바에서 하던것처럼 외부접근을 막을 수 있으나, 안타깝게도 자바스크립트에는 그런 기능이 없었다.

그러나, 최근 업데이트된 private field 제안을 통해서 prviate의 구현이 가능하다.

예를들어

```js
class Person {
  #name = "";

  constructor(name) {
    this.#name = name;
  }
}
```

해당과 같이 인스턴스의 프로퍼티가 될 변수 앞에 #을 붙여주면 외부에서 접근하려고 할 시, 에러를 내보낸다

그리고 애초부터 프라이벳 필드는 마치 스태틱처럼, 인스턴스화하면 그 안에는 존재하지 않는 값처럼 여겨진다. 실제 new 를통해 인스턴스화한 객체 자체를 콘솔로 찍어보면 #name이라는 프로퍼티는 존재하지 않는다.(근데 특이한건 에러는 private이라서 안된다고 나온다. undefined가 아닌)

즉, 정리하자면

static => 초기화하기 전 접근가능 // get, set형태로 접근가능 // 인스턴스 접근 "x"

private 필드 => 초기화전 접근 "x" // get, set 형태로 접근가능 // 인스턴스 접근 "x"

아쉬운 점은 애초에 컴파일 시점에서 그것을 인지하고 에러를 빨간줄로 쳐주면 좋겠다는 점이지만... 자바스크립트니 어쩔수가 없다.

거기다가, private 필드형태를 쓰기 위해서는 저렇게 클래스 몸체에 클래스 필드 형태로 구현해야 한다. 클래스 필드란, 자바에서 클래스를 이야기할때 인스턴스에 들어갈 프로퍼티들을 이야기할때 필드라고 이야기하는데 그것을 자바스크립트 형식으로 가져온것이다.

해당 내용이선 #name = ""; 부분이 클래스 필드에 해당한다.

> 내 생각에는 private 필드의 특징이 객체 지향적 개발에 알맞는 형태라고 본다. 인스턴스에서 구현조차 되지 않고, 초기 생성자 클래스에서도 접근이 불가능하며, 유일한 방법은 getter과 setter로만 가능한 점은 객체 지향형 개발의 은닉화와 캡슐화, 그리고 이를 통한 추상화를 구현할 방법으로 아주 유용해보인다.

class 의 private 필드에서 가장 중요한 것

1. #을 이용한 클래스 필드 정의로 만들 수 있다
2. 인스턴스화 하기 전에 생성자에서 접근이 불가능하다
3. 인스턴스한 후에는 해당 객체에 값이 존재하지 않고, 접근하려하면 private 에러를 낸다
4. 유일한 접근방법은 메소드를 통해 this형태로 접근하는 것 뿐이다
5. 단 여기서 조심해야 할 점은 private필드에 접근하기 위해 this를 사용할 경우, 이 this는 해당 private 필드를 포함하고 있는 클래스를 의미한다(만들어질 인스턴스가 아니다. 빌어먹을 this) 따라서 해당 Private 필드는 해당 private 필드 안에서만 접근이 가능하도록 구현되어 있다.

---

이벤트의 위임(html)

일반적으로 버블링을 통해 이벤트는 상위로 전파된다.
근데 이런 쓰달데기없어보이는 시스템이 왜 있는걸까? 이것은 바로 이벤트 위임을 통해 하위에 모든 요소들이 다 특정한 핸들링 함수를 갖지 않도록 하는데에 있다.

예를들어, onClick때마다 무언가를 하는 컴포넌트들이 수백만개가 있다고 가정하자.

그럼 이 행동을 처리하기 위한 함수가 각 컴포먼트마다 등록되야되고, 그 행동이 수백만번 반복되는 것이다. (예를들어, 리엑트에서 forEach로 수백만개의 컴포넌트에 단 하나의 onClick 프로퍼티를 등록을 위한 짓을 한다고 생각해봐라. 골치아프다)

이런 비효율을 없애기 위해, 버블링을 통한 비효율의 감소를 가져와볼 수 있겠다

예를들어, 자식요소가 수백만개가 된다 하더라도 결국 클릭 이벤트가 발생하면
브라우저에 의해 이벤트 객체가 생성이되고 1. 캡쳐링, 2. 캡쳐+타겟, 3. 버블링 순서로 행위가 일어날것이다.

즉, 어찌되었든 부모 역시 어떠한 이벤트에 대한 행동을 인지하고 있으므로, 그 부모에게 click 이벤트에 대한 행동을 처리하는 함수를 달아두면 그 하위에 수백만개의 컴포넌트에 이벤트 핸들러를 등록하는 짓을 하지 않아도 된다는 것이다.

구현방법은 이러하다

```js
parent.onClick = ({ taget }) => {
  //이벤트 발생시킨 대상이 paretn의 자식 중 아무거나 다 캐치하고 있으므로,
  // 이를 리턴으로 처리하기 위한 문구
  // target 객체에 존재하는 matches 메소드는 인자로 오는 스트링 값으로 전체 Dom을 기준으로 해당 스트링 값에 대해 target이 true한지를 매치해본다. 예를들어 "#fruit > li" 와 같이 클래스 선택자처럼 쓰면 된다.
  if (!target.matches("자식을 탐색하는 선택자 형태를 쓴다")) return;
};
```
