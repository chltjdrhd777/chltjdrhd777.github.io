# **코어 자바스크립트 공부내용 정리**

![javasciprt](https://img.shields.io/badge/javascript-up%20to%20date-yellow)

![typescript](https://img.shields.io/badge/typescript-up%20to%20date-blue)

---

# class

자바스크립트의 클래스는 일반적으로 public하다
이 말인즉슨, 인스턴스화 시키면 외부에서 접근이 자유롭다는 뜻이다.

타입스크립트를 이용하면 readonly나 private과 같은 키워드를 통해서 자바에서 하던것처럼 외부접근을 막을 수 있으나, 안타깝게도 자바스크립트에는 그런 기능이 없었다.

그러나, 최근 업데이트된 private field 제안을 통해서 prviate의 구현이 가능하다.

예를들어

```js
class Person {
  #name = "";

  constructor(name) {
    this.#name = name;
  }
}
```

해당과 같이 인스턴스의 프로퍼티가 될 변수 앞에 #을 붙여주면 외부에서 접근하려고 할 시, 에러를 내보낸다

그리고 애초부터 프라이벳 필드는 마치 스태틱처럼, 인스턴스화하면 그 안에는 존재하지 않는 값처럼 여겨진다. 실제 new 를통해 인스턴스화한 객체 자체를 콘솔로 찍어보면 #name이라는 프로퍼티는 존재하지 않는다.(근데 특이한건 에러는 private이라서 안된다고 나온다. undefined가 아닌)

즉, 정리하자면

static => 초기화하기 전 접근가능 // get, set형태로 접근가능 // 인스턴스 접근 "x"

private 필드 => 초기화전 접근 "x" // get, set 형태로 접근가능 // 인스턴스 접근 "x"

아쉬운 점은 애초에 컴파일 시점에서 그것을 인지하고 에러를 빨간줄로 쳐주면 좋겠다는 점이지만... 자바스크립트니 어쩔수가 없다.

거기다가, private 필드형태를 쓰기 위해서는 저렇게 클래스 몸체에 클래스 필드 형태로 구현해야 한다. 클래스 필드란, 자바에서 클래스를 이야기할때 인스턴스에 들어갈 프로퍼티들을 이야기할때 필드라고 이야기하는데 그것을 자바스크립트 형식으로 가져온것이다.

해당 내용이선 #name = ""; 부분이 클래스 필드에 해당한다.

> 내 생각에는 private 필드의 특징이 객체 지향적 개발에 알맞는 형태라고 본다. 인스턴스에서 구현조차 되지 않고, 초기 생성자 클래스에서도 접근이 불가능하며, 유일한 방법은 getter과 setter로만 가능한 점은 객체 지향형 개발의 은닉화와 캡슐화, 그리고 이를 통한 추상화를 구현할 방법으로 아주 유용해보인다.

class 의 private 필드에서 가장 중요한 것

1. #을 이용한 클래스 필드 정의로 만들 수 있다
2. 인스턴스화 하기 전에 생성자에서 접근이 불가능하다
3. 인스턴스한 후에는 해당 객체에 값이 존재하지 않고, 접근하려하면 private 에러를 낸다
4. 유일한 접근방법은 메소드를 통해 this형태로 접근하는 것 뿐이다
5. 단 여기서 조심해야 할 점은 private필드에 접근하기 위해 this를 사용할 경우, 이 this는 해당 private 필드를 포함하고 있는 클래스를 의미한다(만들어질 인스턴스가 아니다. 빌어먹을 this) 따라서 해당 Private 필드는 해당 private 필드 안에서만 접근이 가능하도록 구현되어 있다.

---

이벤트의 위임(html)

일반적으로 버블링을 통해 이벤트는 상위로 전파된다.
근데 이런 쓰달데기없어보이는 시스템이 왜 있는걸까? 이것은 바로 이벤트 위임을 통해 하위에 모든 요소들이 다 특정한 핸들링 함수를 갖지 않도록 하는데에 있다.

예를들어, onClick때마다 무언가를 하는 컴포넌트들이 수백만개가 있다고 가정하자.

그럼 이 행동을 처리하기 위한 함수가 각 컴포먼트마다 등록되야되고, 그 행동이 수백만번 반복되는 것이다. (예를들어, 리엑트에서 forEach로 수백만개의 컴포넌트에 단 하나의 onClick 프로퍼티를 등록을 위한 짓을 한다고 생각해봐라. 골치아프다)

이런 비효율을 없애기 위해, 버블링을 통한 비효율의 감소를 가져와볼 수 있겠다

예를들어, 자식요소가 수백만개가 된다 하더라도 결국 클릭 이벤트가 발생하면
브라우저에 의해 이벤트 객체가 생성이되고 1. 캡쳐링, 2. 캡쳐+타겟, 3. 버블링 순서로 행위가 일어날것이다.

즉, 어찌되었든 부모 역시 어떠한 이벤트에 대한 행동을 인지하고 있으므로, 그 부모에게 click 이벤트에 대한 행동을 처리하는 함수를 달아두면 그 하위에 수백만개의 컴포넌트에 이벤트 핸들러를 등록하는 짓을 하지 않아도 된다는 것이다.

구현방법은 이러하다

```js
parent.onClick = ({ taget }) => {
  //이벤트 발생시킨 대상이 paretn의 자식 중 아무거나 다 캐치하고 있으므로,
  // 이를 리턴으로 처리하기 위한 문구
  // target 객체에 존재하는 matches 메소드는 인자로 오는 스트링 값으로 전체 Dom을 기준으로 해당 스트링 값에 대해 target이 true한지를 매치해본다. 예를들어 "#fruit > li" 와 같이 클래스 선택자처럼 쓰면 된다.
  if (!target.matches("자식을 탐색하는 선택자 형태를 쓴다")) return;
};
```

<추가내용 = 커스텀 이벤트>

브라우저에는 특정 유저 인터페이스로부터 입력되는 행위에 대해서 이것이 어떤 이벤트인지 인지하고 그것에 대한 이벤트객체를 만들 수 있도록 이벤트 생성자 함수를 가지고 있다고 하였다

그런데, 이것 말고도 브라우저는 커스터마이징을 위한 생성자 함수 또한 마련해두고 있다.

예를들어, 내가 원하는 유저의 행동양식이 단순한 **클릭** 만이 아니라, 클릭 후 마우스를 위 아래 좌 우 형식으로 이동시켰을 때만 그것을 이벤트로 인식하고 발동해야 한다, 라는 이벤트가 있다고 하자

이것을 일일이 클릭 and moseMove 위 아래 좌 우 하나하나 다 매번 써내려가기는 몹시도 귀찮은 일이다. 차라리 이 모든 행동을 하나의 이벤트라고 인식시키는 커스텀 이벤트가 존재한다면 편할것이다

그래서 있다 그런게

CustomEvent라는 객체는 원하는 특정 행위에 대한 것을 인식하여 이벤트 객체를 만들어주고, 이것은 마치 리듀스에서 봤던 디스패치처럼 해당 객체를 전달하면서 호출하면 실행하도록 유도하는 디스패치 메소드가 모든 노드객체에 존재한다.

예를들어,

```js
const button = document.querySelector(".testBtn");

button.addEventListner("foo", (e) => {
  console.log(e);
});

const customEvent = new CustomeEvent("foo", {
  detail: { message: "it is custom" },
});

button.dispatchEvent(customEvent);
```

위와같은 형식으로 썼을 경우, DOM에 존재하는 노드 중 버튼을 상수로 할당한 다음, 거기에 이벤트 리스너를 등록해준다(저 리스너는 노드의 이벤트 리스너를 담당하는 자료구조에 해당 이벤트 이름으로 담겨져 있다. 즉, 저기에서는 키가 'foo' 이고, 값은 화살표 함수인 것으로 등록되어 있는 상태)

그리고 나서 우리는 동기적으로 해당 이벤트를 격발시킬 수 있다. 그 뒤에 foo 이벤트를 발동시키기 위한 객체를 생성자 함수로 만든다.

그 객체에 두번째 인자로 들어가는 것은, 해당 이벤트 객체에 그대로 반영되는 것으로서 커스텀 이벤트 객체에 존재하는 detail 부분에 해당 값을 넣어서 전달할 수 있다.

---

참고로, 모든 이벤트에 대해서 직접 생성자 함수를 통하여 객체를 생성하고, 그 객체를 디스패치 함수를 통해 전달하여 임의적으로 해당 이벤트를 실행시킬 수 있다.

생성자 함수의 첫째 인자로 들어가는 스트링값은

이벤트 객체에 공통적으로 존재하는 프로퍼티 "type" 에 할당된다.

예를들어, addEventListener("click",()=>{})
에서 저 클릭이라는 스트링값이 type에 할당되는 것과 같은

형태다. 그리고 그 뒤에 두번째 인자로 들어가는 객체의 키와 값은 해당 이벤트 객체에 이미 존재하는 키와 매칭되어 값이 전달된다.

예를들어 click이벤트에 대한 커스텀 이벤트 객체를 만들 때 둘째 인자에

```js
new MouseEvent("click", {
  bubbles: true,
  cancelable: true,
  clientX: 50,
  clientY: 100,
});
```

와 같은 형태로 쥐어주고 만든다면, 해당 이벤트 객체에 저 정보들이 담기게 된다는 소리다.

그리고 나서 저 객체로 디스패치를 실시하면 해당 정보를 가지고 이벤트가 동기적으로 발생하는 효과를 가진다.

참고로, 이러한 형식의 임의적인 이벤트 발생은 오로지 addEventListner로만 가능한데,

그 이유는 addEventListner은 자신만의 특이한 이벤트 관련 자료구조에 전달되는 이벤트 타입을 키로 하여 거기에 값으로핸들러를 할당하고 브라우저가 "야 이런 이벤트 발생했음, 이벤트 핸들러 실행해" 라고 명령했을 때,

해당 노드객체가 "어, 보자... 어 내 이벤트 리스터에 요로코롬 해당 키에 대한 핸들러가 있네? 실행하자" 라는 형태가 될 수 있지만,

프로퍼티 형식으로 지정한 이벤트핸들러는 커스터마이징을 할 수가 없다. 왜냐하면 프로퍼티 형식은 프로토타입 체인에 의해 연결되어 있는 이벤트 타겟의 프로퍼티들에 해당 함수값을 지정해주는 형태로 이루어져 있다.

따라서, 이벤트 타겟의 프로퍼티에 우리의 임의의 이벤트에 대한 것을 키로 설정하여 넣어줄 수가 없기 때문에 그렇다.
