# **any vs object vs {}**

![javasciprt](https://img.shields.io/badge/javascript-up%20to%20date-yellow)

![typescript](https://img.shields.io/badge/typescript-up%20to%20date-blue)

---

# 항상 뭘써야할지 헷갈렸는데 스텍오버플로우에 있는 내용을 보고 번역하며 공부해본다

1. any : 그냥 어떤것이든 될 수 있다. 컴파일러는 그 맴버에 대해서 알지 못하며, 그래서 해당 파트에 접근하거나 할당하거나 하는 행동에 대해서 타입체크를 하지 않는다. (한마디로 최악의 방법이다)

2. object : 객체 인터페이스를 띈다. 이게 무슨 의미냐면, 자바스크립트의 객체 형태를 기억하면 되는데, 여기서 typeof로 정의했을 시에 object로 표현되는 애들은 다 들어갈 수 있다는 소리다.(단 null은 제외다. 애는 자바스크립트 에러같이 남아서 객체로 표현되지만 타입스크립트는 엄격하게 앤 null이라고 정의하고 있다) 예를 들어

```ts
let test: object;
test = {}; // ok
test = []; // hahaha... ok 왜냐면 배열도 객체거든
test = function () {}; // hahaha ok 왜냐면 함수도 객체거든
test = 42; // 뭔소리고
test = "hello"; // 뭔소리고
test = null; // 뭔소리고
test = false; // 뭔소리고
test = undefined; // 뭔소리고
```

3. {} : 그럼 얘는 뭘까. 얘는 타입스크립트 입장에서 보면 조금 더 느슨한 느낌의 친구다. object는 진짜로 타입정의시 객체인걸 받아온다면 얘는 "object일수도 있고 아닐수도있고, 비어있을수도있고.. 하여간 그래" 라는 느낌이다. 그래서그런지

```ts
let test2: {};
test2 = []; // ok
test2 = 100; // ok .........
test2 = "hello"; // ok....
test2 = null; //안돼
```

이처럼 undefined, null 과같은 애들을 제외하곤 다 받아들인다.
그럼 얘는 있을 필요가 없는거같다만, 저렇게 빈객체 형태로 받는건 솔직히 쓸모를 잘 모르겠고, 정확하게 정의내리는 경우와
ex {name : string}

아니면, 컴퓨티드 프로퍼티처럼 사용하는 경우라면 조금 실효성이 있다. 예를들면

```ts
let test : {[key : string]:any}
//해당 키에 대한 벨류평가가 그 어느것이든 된다면, 이것이 뜻하는 바는 비어있는 객체(혹은 배열) 역시도 정의 가능하다는 소리가 된다. 그 외에는 다 에러가 되서 좋긴한데 배열도 따지고보면 프로토타입을 빼고 보면 그냥 객체랑 다를 바가 없어서 빈객체든 아니면 뭐가 들어있든 객체든 다 포함시킬수있다는 문제가 있다. 그래서

let test : {[key:string]:string} 와 같이 명확하게 정의된 타입을 쓰도록 하자


```

한줄결론
해당 타입이 객체여야한다면 object 를 쓰고 객체 안에 뭐가 들어있는 상황이라면 명확하게 정의하자
