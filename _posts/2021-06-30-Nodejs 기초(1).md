# **NodeJs의 기본내용을 정리해보았다(1).**

![javasciprt](https://img.shields.io/badge/javascript-up%20to%20date-yellow)

![typescript](https://img.shields.io/badge/typescript-up%20to%20date-blue)

---

## 시작하기 앞서

1. 순수한 자바스크립트는 싱글 스레드로, 하나에 하나의 일처리를 한다.
2. 하지만 이 자바스크립트 파일을 실행시켜 평가하는 호스팅 환경이(ex 브라우저) 비동기적인 작동을 가능케 한다(Promise 객체 지원 등)
3. 하지만 NodeJs 가 나타난 이후, 이 NodeJs 환경에서도 자바스크립트를 호스팅 할 수 있게 되었다.
4. NodeJs 의 비동기적 작업은 내부의 라이브러리를 통하며 크게 6개의 페이즈를 순환한다.
5. 각 단계는 first in first out인 큐의 형태를 따른다.
6. 따라서 들어오는 스크립트에 대해 각 단계별로 정해진 작업을 수행할 수 있는데,
7. 각 단계에서 큐에 더이상 들어올 것이 없게 되거나 콜백의 최대갯수(콜백할 수 있는 한계가 정해져 있음)에 다다를때까지 작업을 실행하고
8. 그 이후 다음 단계로 이동한다

```js
//6개의 페이즈 설명
1. timers phase = 지정된 일정 시간 후에 콜백을 실행하도록 정하는 페이즈.

(예를들어, 해당 페이즈의 작업 한계 임계점을 100ms 로 정해놓고, 실행을 돌렸을 경우)
(비동기적인 작업이 이벤트 루프로 들어가기 전 fs.readFile()와 같은 100ms 이하의 작업이 호출된 후 완료되지 않아 기다리게 되는 경우라면, 재빨리 Date.now()를 이용하여 지연시간을 계산 후, 10ms 이하의 작업을 poll 큐에 넣어 실행하는 페이즈를 진행한다. 즉, 10ms의 작업이 poll페이즈에서 작업을 끝마치고, 다시 timers 단계로 돌아가 완료된 fs.readFile()와 같은 작업을 이벤트루프에 넣고 실행시킨다.)


2. pending callback phase = TCP 오류에 대한 콜백을 실행하는 부분
(참고로 TCP란, Transmission Control Protocol)의 약자로, 데이터 흐름에 대한 수신측과 송신측의 제어 방식과 규칙을 뜻한다. TCP의 전송제어방식은 1.흐름제어(전송되는 양을 조절) 2.오류제어(제대로 전송이 안됬을 시 처리방식) 3.혼잡제어(네트워크가 혼잡할 때에 실행할 방식) 으로 나누어진다. 보통 TCP 오류라 함은 수신측이 송신측의 데이터를 다 처리할 수 있는 역량이 된다면 문제가 되지 않으나, 송신측에서 수신측이 받아들일 수 없는 너무나도 많은 양을 전달할 경우 문제가 된다.
수신측과 송신측은 각각 자기가 받아들일 수 있는 한계점이 되는 '버퍼' 라는 설정이 존재한다. 수신측은 자신이 받아들일 수 있는 데이터양을 나타내는 지표인 윈도우 크기(window size) 라는 정보를 서버에 요청시 헤더에 담아서 전달하고, 서버는 이 내용을 보고 얼마정도의 양을 전달해야 할지 결정한다.

단, 이때 여러 기법이 생겨났는데
a. stop and wait : 서버야, 일단 데이터 보내봐 내가 수용 가능하면 오케이 보내줄테니 그 뒤에 또 보내 (서버가 보내고 클라이언트측에서 수용가능성을 확인해야하는 구조라 매우 비효율적)

b. sliding window : 서버야, 나는 이정도 처리가 가능하니까 너가 얼마나 보낼지 결정해줘 (서버는 클라이언트가 요청시에 보낸 버퍼 정보와 자신이 보낼 수 있는 버퍼의 양을 고려한 뒤, 윈도우 크기를 결정한다. 이 때에 결정 요인은 외부적인 환경도 다 고려된 만큼의 양이다. 예를 들어, RTT, 즉 Round Trip Time 과 같은 왕복시간의 계산결과에 대한 요소를 고려한다. 즉 네트워크의 복잡도를 고려할 수 있다는 의미가 된다. 이 때에 왜 이 기법이 sliding이라는 명칭이 붙었냐면, 아까 송신측과 수신측은 다들 임계점을 나타내는 버퍼와, 얼마만큼 보낼지를 결정하는 즉 담아두는 양을 결정하는 윈도우 사이즈가 있다고 했다. 그렇다면 서버가 클라이언트에게 특정 윈도우 사이즈만큼 데이터를 보낼 시, 수신측은 그것을 받아 버퍼에 집어넣어본 후, 얼마만큼의 공간이 비었으니 더 보내도 괜찮을거같다. 는 신호를 전달하게 된다. 그리고 나서 받아온 윈도우 사이즈만큼의 데이터를 이용가능한 공간만큼 뒤로 미루고, 그 공간의 정보를 서버측에 보내 이만큼 더 보내줘! 할 수 있는 것이다. -물론 무작정 계속 늘리는 게 아닌, 송신측의 윈도우 사이즈까지만큼 늘릴 수 있다- 이렇게 뒤로 미루는 기법떄문에 sliding이라는 명칭이 붙었다.)

3. poll phase = 아까 타이머 페이즈와 연관되어있듯, 들어오는 정보와 나가는 정보를 얼마나 오랫동안 블록하고 이것을 판단해서 폴링할지말지를 결정하는 부분이다. 만약 poll의 큐가 비어있지 않으면, 이벤트 루프는 다시금 콜백의 큐를 순회하여 큐를 다 소진하거나 하드의 임계점 리미트가 될 때까지 동기적으로 콜백을 실행한다. 만일 poll 큐가 비어있다면, setImmediate() 으로 스케쥴링되어있는 스크립트가 존재한다면 그 스크립트를 실행하기 위해 다음 phase인 check phase로 넘어간다. 만약 '다음에 할 내용이 스케쥴되어 있지 않은데요?' 라면, 이벤트루프는 타이머 페이즈에서 봤던 것처럼 특정 작업의 시간 임게점이 넘어가고 있는지를 확인한 후, 넘어갈 시에 예를 들어 10ms 이하의 작업을 선별하여 그것을 콜백형식으로 큐에 담아 실행시키고, 타이머가 완료되면 타이머 페이즈로 돌아가 그 타이머의 행동을 완료시킨다.
```
