# ** useCallback을 언제 써야할까 **

![javasciprt](https://img.shields.io/badge/javascript-up%20to%20date-yellow)

![typescript](https://img.shields.io/badge/typescript-up%20to%20date-blue)

---

예를 들어,

useEffect와 같은 상황을 다시 생각해보면,

이 함수는 랜더링의 시점에는 작동하지 않고 호출당시에 그냥 콜백을 저장해두고 있다가, 모든 랜더링이 끝나면 그제서야 콜백을 가지고와서 실행을 시킨다.

그리고 나서 dependency의 안에 있는 내용물이 바뀔 때마다 즉각즉각 호출되어 메모이제이션되어있는 콜백을 다시금 호출하는 역할을 하는데,

만약에 이 useEffect에서 상태를 업데이트해서 리랜더링이 되던가, 아니면 프롭으로 받아오는 값에 의해 컴포넌트가 리랜더링이되든가 하는 상황을 가정하면

그때마다 안쪽에 선언해둔 함수들을 반복해서 평가하고 함수객체를 만드는 것은 비효율적이므로

useCallback을 통해 메모이제이션할 함수들을 감싸주어 따로 저장해준다고 전에 정리를 해두었다.

근데 useCallback에도 역시 dependecy가 존재하는데, 이 녀석의 의미를 제대로 파악하지 않고 넘어가서 정리한다

useCallback의 두번째 인자인 dependency 배열안에는, 어떤 때에 첫번째 인자의 콜백을 업데이트해야하는지를 나타내는 지표다. 예를 들어,

콜백 안에 있는 내용물에서 무언가 특정한 상태를 참조하고 있는 상황이라고 가정하자.

useCallback은, 첫 호출 당시에 첫번째 인자의 콜백을 메모이제이션하게될텐데, 이 때에 내부에서 참조하고 있던 상태는 항상 최신의 것이라는 보장이 없다(예를 들어, 버튼을 눌러서 상태가 변경하든가 하는 상황)

그 때에 dependency에 변화가 일어나게 되는 값들을 설정해두면, useCallback이 useEffect때와 마찬가지로 그 변화를 감지하고 있다가, 콜백 안에서 참조하고 있던 상태를 변화된 새로운 상태로 교체하여 최신버전으로 만들어준다.

# React.memo ?

얘가 하는 일은 간단하게 정의 가능하다.

prop의 내용물이 바뀔때만 컴포넌트를 리랜더링하고 그 이외에는 리랜더링을 하지 않고 메모이제이션된 컴포넌트를 그대로 재활용한다.
그럼 이 때에 살짝쿵 고려해볼 내용이 있는데, 만약 React.memo로 기억해둔 컴포넌트가 프롭으로 부모에 상태를 받아오고, 부모의 상태를 변경가능한 함수를 받아왔다고 치자.

이 함수는 useCallback을 통해 메모이제이션되어있는 상태고, 부모쪽 특정 상태가 바뀌면 최신으로 업데이트되도록 설정해뒀다고 가정했을 때,

이 자식 컴포넌트가 여러개 있을 경우

어느 한쪽 자식 컴포넌트에서 버튼을 클릭하든지 하여 부모로부터 받아온 함수를 실행시켜 부모쪽 상태를 변경했다면

부모의 상태가 바뀌었으니 자식쪽의 prop이 바뀌었고,
그러면 결국 자식들이 전부 싸그리 리랜더링되는 참으로 useMemo가 의미없는 상황이 발생한다.

그래서 추천하는 것은

useCallback의 dependency는 만약 상태변경을 할 경우라면 함수형으로 업데이트하는 것을 이용하는 것이 좋다
즉, setState(prev => !prev) 와 같은 형태로 두고, dependency를 빈 배열로 설정하는 것이 낫다는 의미다

저 때에는 항상 콜백의 인자로 받는 prev가 리엑트의 useState 공간 안에 저장되어 있는 가장 최근의 상태주소를 참조하기때문에 굳이 dependency에 최신 업데이트를 위한 의존성을 넣어줄 이유가 사라지게 된다.
