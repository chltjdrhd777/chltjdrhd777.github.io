# **clean up?**

![javasciprt](https://img.shields.io/badge/javascript-up%20to%20date-yellow)

![typescript](https://img.shields.io/badge/typescript-up%20to%20date-blue)

---

## useEffect를 쓰다 보면

예를들어, 어떤 상태를 변경하는 함수가 있다고 하자. 이 함수는 그 내부에서 useEffect를 통해 sideEffect로 비동기적인 행동을 처리한 후에 그것을 내부 컴포넌트의 상태로 저장한다.

근데 이런 경우가 있지 않겠는가

어떤 참을성 없는 유저가 버튼을 눌러놓고 그대로 응답을 받기도 전에 다른 사이트로 가버린다.

그럼 리엑트 입장에선 이제 라우팅을 통해 다른 컴포넌트 함수객체가 계산되어 페인팅되어있고, 자바스크립트 엔진을 통해 비동기로 작업을 마친 함수처리는 그 뒤에 존재하지도 않는 컴포넌트 객체의 상태를 업데이트하려고 시도할 것이다.

이럴때 물론, 존재하지도 않는 상태에 업데이트 하려고 시도하는 것은 에러를 만들진 않는다. 하지만, 리엑트는 친절하게 해당 내용이 쓸데없는 계산을 하는 메모리 누수라고 설명해주고, 이것을 해결해달라고 요청한다.

이것이 바로 클린업 함수의 존재 의미이다.

즉, react의 가상 공간 안에 등록되어 있는 useEffect의 콜백 함수의 추적을 풀기 위해서는 명시적으로 return되는 함수값이 존재해야 한다는 뜻이다.

해당 값이 존재한다면, 리엑트는 언마운트되는순간 콜백함수의 추적을 풀면서 리턴되는 함수를 실행시키고 행동을 종료할 것이다.

클린업 함수를 작성하는것은 간단하다. 해당 메모리 누수가 예상되어보이는 useEffect 함수에 내부에서 컴포넌트 함수객체가 언마운트가 되었을 때에 실행해줘야 하는 함수를 작성해 리턴해주면 된다.
