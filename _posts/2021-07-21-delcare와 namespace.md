# ** typescript의 namespace와 declare 정리 **

![javasciprt](https://img.shields.io/badge/javascript-up%20to%20date-yellow)

![typescript](https://img.shields.io/badge/typescript-up%20to%20date-blue)

---

매번 타입스크립트 이용할때마다 declare이 나오면 쫄아가지고 아무것도 못했다. 이번에는 좋은 자료가 있어서 내 나름대로 정리하기 위하여 쓰게 되었다.

## 0. 모듈이란

자바스크립트는 기본적으로 모듈이란 개념이 없었다. 외부 서버에서 요청을 실행하여 받은 html에 대해서 위에부터 이 문서를 읽어가다가 script 태그를 발견하게 되면 서버에 이것을 요청하고, 받은 자바스크립트를 브라우저의 자바스크립트 엔진을 통해

1. 토큰분해
2. syntax tree 형성
3. 바이트코드로 전환하여 평가와 실행
   라는 과정을 거치는데, 이 때에 평가하고 실행 (즉 실행 컨텍스트를 만들어서 그 안에서 변수정의, scope정의, this 정의) 등을 실행한 결과값을 브라우저에서 형성하는 window 객체의 내부에다가 차곡차곡 저장해 나갈 때에, 이 전역적인 환경 아래에서 모든 것이 다 적용이 된다.

무슨 말이고 하니

```js
<script src =".....a"/>
<script src =".....b"/>

이렇게 되어있는데 만약 윗쪽에 "var a = "hello"" 라고 정의된 변수가 있고, 아래쪽에 "var a = "hello2" 라고 정의되어 있다면 위의 var a 가 밑의 var a 에 오버라이트되는 상황이 올 수 있다는 것이다.
```

이런 상황을 벗어나기 위해 개발된 ES6에서 전격 도입된 것이 모듈이며, 원래는 node환경에서만 볼 수 있던것을 클라이언트단에서도 적용이 가능하게 되었다. 이 모듈은 각 파일마다 독자적인 스코프를 가지고 있으므로, 서로의 스코프적인 간섭이 일어나지 않게 된다.

## 2. namespace

타입스크립트에서의 namespace는 그 의미 자체로는 정확하게 이해하기 어려운데, javascript로 컴파일된 결과물을 보면 어렴풋이 이해가 될듯말듯할수 있다

참고로, 타입스크립트 파일이 자바스크립트로 트랜스컴파일될때에 "변수,상수,함수,클래스" 는 자바스크립트 모듈 로더에 의하여 변환되고, "타입" 정의들은 모두 무시된다. 그리고 "네임스페이스" 는 즉시실행함수(IIFE, Immediately Invoked Function Expression)으로 감싸져서 내부 안에서 알아서 뚝딱뚝딱 하여 나온 객체 결과물이고, 이것을 외부에서 접근이 불가능한 형태다(네임스페이스가 기본적으로 외부에서 내부의 값들을 함부로 접근하지 못한다는 것을 구현하기 위함이다)

```js
// TypeScript
namespace N1 {
    export let a: string = 'a';
    let b: string = 'b';
    console.log(a);
    console.log(b);

    export namespace N2 {
        export let c: string = 'c';
        let d: string = 'd';
        console.log(c);
        console.log(d);
    }
}

// Compiled JavaScript
"use strict";
var N1;
(function (N1) {
    N1.a = 'a';
    let b = 'b';
    console.log(N1.a);
    console.log(b);

    let N2;
    (function (N2) {
        N2.c = 'c';
        N1.N2 = N2;
        let d = 'd';
        console.log(N2.c);
        console.log(d);
    })(N2 = N1.N2 || (N1.N2 = {}));
})(N1 || (N1 = {}));//이 부분은 N1이 있으면 그것을 변수로, 아니면 빈객체를 변수로 사용하라는 소린데 현재 N1에 담긴 것이 아무것도 없으므로 빈객체가 지역변수로 선언된다. 해당 내용에서, 네임스페이스의 export로 외부에 내보내야 하는 내용은 자바스크립트 버전으로 보면 즉시실행함수상에서 프로퍼티 지정으로 설정하는 것을 확인할 수 있다. 즉, 즉시실행함수의 내부에 지정되어있는 변수 d는 접근이 불가능하다.
```

## 3. declare

대망의 declare다. 맨날 이것때문에 헷갈려했으니 제대로 파악하자

다시정리하면

"네임스페이스" = 외부에서 접근하지 못하고 안쪽에서 외부에 노출시키고 싶어하는 내용들만 노출하는 방식. 듣자하니 뭔가가 떠오르지 않은가? 객체지향적인 개발, 캡슐화 은닉화,추상화 온갖 내용이 떠오르지않은가. 내 개인적인 평가로는, 타입스크립트의 객체지향적 방식을 나타낸 녀석이라고 생각한다.

그럼 "Declare"은?

declare은 애초에 자바스크립트로 변환도 되지 않고, 오로지 하는 내용은 해당 변수와 상수 함수 클래스가 어디에 이미 선언되어 있음을 나타내주는 것을 말한다.

이때 declare은 ambient context로 정의되는 영역이다.
ambient context는 간단하게 말해, 타입스크립트가 해당 타입을 확인하기 위해 파일들을 거슬러 올라가며 확인해나갈 때에 최종적으로 파악하지 못했을 경우 건드리게 되는 영역이다.

declare은 중요한 특성이 있다

1. 이 영역 안에서는 declare가 기본적으로 붙게 되므로, 굳이 붙여주지 않아도 된다. 또한, 선언과 관련된 내용이 아닌 일반 스크립트 코드는 사용할 수 없다.

2. declare namespace : 자바스크립트로 컴파일되지 않는다.
   그리고 declare 안에 선언되는 것엔 declare이 기본적으로 붙게 되므로, declare 안의 네임스페이스 역시 동일한 상황이다. 이 형태는 이른바 **내부모듈** 라고 칭해지며, JS 모듈이 내보내는 것이 객체일 경우 그 객체의 타입정보만을 알리기 위한 목적을 가진다.

3. declare module : **외부모듈** 이라고 칭해지며, 이런 앰비언트 모듈선언은 컴파일이 진행되는 당시에 그 대상에 포함되기만 한다면 그 안에 선언되어 있는 타입정보들을 사용하고 참조할 수 있게 된다. 또한 마찬가지로 이 declare module 선언 역시 내부에 export가 붙여진 필드만 외부에서 참조가 가능하다.

4. delcare global : 전역적으로 사용되는 타입참조를 선언하고 싶을때에 이 안에다가 작성한다. 전역적으로 사용된다함은, 해당 안의 내용물을 참조하기 위해서 별도로 임포트와 같은 행위를 할 필요가 없다는 소리다.

## d.ts파일

오로지 선언만을 위한 파일들을 담는 용도로 쓰는 파일이다.
JS로 컴파일되지 않는다
만약 tsconfig.json의 skipLibCheck에 해당하는 프로퍼티의 벨류가 false라면, 다음 규칙을 반드시 지켜야한다.

1. 선언만 가능하고, 일반 코드는 쓸 수 없다.(declare의 특성)
2. 최상위에 선언되야하는 변수타입,상수타입,함수타입,클래스타입,네임스페이스타입 선언 앞에는 반드시 declare이나 export를 붙여줘야 한다.
3. 그 내부의 블록안에서는 export가 기본으로 붙으므로, 따로 붙일 필요는 없다.
