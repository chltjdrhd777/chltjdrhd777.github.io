# **module.exports의 정체**

![javasciprt](https://img.shields.io/badge/javascript-up%20to%20date-yellow)

![typescript](https://img.shields.io/badge/typescript-up%20to%20date-blue)

---

node를 사용하다보면 모듈시스템으로 commonJs 즉 require과 module.exports의 형태를 따르고 있다는 것을 알 수 있다.(엄연히 말하면 브라우저도 해당 문구를 통해 받아들여지는 내용물을 바벨로 컴파일하고 있지만 여튼)

그런데 이때 난 늘 궁금했다

도대체 module이 뭐길래 노드에서는 자바스크립트가 자동으로 인식해서 가져올 수 있는것일까? 그럼 module이라는 존재는 뭘까.

단도직입적으로 말해서, module은 노드가 프로세스로서 실행되면서 자바스크립트 스레드에서 자바스크립트를 읽어서 실행하는 과정 가운데 해당 자바스크립트 파일의 컨텍스트로 제공되는 객체다

즉, 구별해야 할 것은 노드의 전역 객체인 global과는 다른 존재라는 뜻이다. 노드는 자신이 실행되면서 가지는 마치 브라우저가 실행되면 해당 탭에서 만들어지는 객체인 window가 존재하듯, 글로벌이라고 하는 객체를 형성한다.

이 글로벌에는 윈도우와 마찬가지로 표준 빌트인 객체와 빌트인 함수, 각종 호스트 객체들을 저장하고 있는데, 이 가운데 우리가 주목해야 할 것은 각 파일에게 전달할 용도로 만들어진 호스트 객체이자 함수인 Module이다.

하나의 자바스크립트 파일은 읽혀지는 순간 글로벌 객체로부터 끄집어내진 이 빌트인 Module생성자를 통해 Module 객체를 만든다.
이 객체에 담겨진 정보는 이와같다

```js
Module {
  id: "해당 파일의 경로",
  exports: "해당 파일의 모듈객체에 존재하는 exports프로퍼티에 담긴 값",
  parent:
    Module { ... }
  filename: '루트부터 시작하여 해당 파일까지의 경로',
  loaded: "해당 모듈객체가 외부에서 임포팅된건가 아닌가",
  children: [],
  paths: [ ... ]
}
```

그리고 나서 만약 해당 파일에서 require()을 사용한다면, 이것은 글로벌에 존재하는 빌트인 함수이므로 즉 객체이므로 그 자신의 안에 프로퍼티를 가지고 있다.

여기에 require.cache를 통해 해당 프로퍼티의 값을 확인해보면, 특정 파일에서 임포트된 모듈객체와, 현재 자기 자신의 모듈객체를 파일까지의 경로를 스트링값으로 갖는 프로퍼티가 저장되어 있다.

require.main은 해당 파일의 안에 존재하는 모듈객체의 정보를 가리킨다.

즉, 이런식으로 각 파일마다 각각 자기 자신의 모듈 객체를 외부 환경으로 갖고 있으며, 이것을 this로 연결하고 있다는 점을 알아야 한다. 단, 브라우저와 다르게 함수에서의 this와 전역에서의 this가 다른데,

함수에서는 this가 글로벌객체를 가리키고 있다면
전역에서의 this는 현재 이 파일에 바인딩되어있는 모듈객체를 의미하고 있다.
