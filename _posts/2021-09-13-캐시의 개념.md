# **효율적인 데이터의 재활용 방법**

![javasciprt](https://img.shields.io/badge/javascript-up%20to%20date-yellow)

![typescript](https://img.shields.io/badge/typescript-up%20to%20date-blue)

---

# 1. 캐시란

캐시는 서버에서 응답받은 static 데이터를 계속해서 사용하게 될 가능성이 있을 경우, 캐시데이터라고 하는 형태로 저장해놨다가
다시금 사용하는 기술을 말한다.

보통 60초정도 유지되는 캐시데이터가 존재하며 한번 서버로부터 해당 데이터의 내용을 받은 후에는 그 시간동안 언제든지 사용했다가
시간이 지나면 비활성화된다. 그 후에는 다시 요청을 해야 한다

그런데 만약, 60초가 지난 이후에도 다시 사용하고 싶다면 어떻게 해야할까. 그럴때는 또 다시 서버에게 요청하기보단
변경점이 없었다면 데이터를 보내지않고 해당 캐시를 다시 부활시키는 것이 나을것이다.

이를 위한 헤더가 'if-modifed-since'와 'last-modified' 이다.

서버는 캐시를 전달할때 헤더로 last-modified라는 이것이 가장 최근에 업데이트된 날짜를 함께 포함하여 전송한다.

그러면 클라이언트는 이 정보를 캐시데이터와 함께 저장하고 있다가 유효시간이 끝나게 된다면 서버에게

'if-modified-since' 라는 헤더를 통해 요청을 보낸다. 서버는 그것을 확인 후 만약 시간의 차이가 없다면 body에 무언가를 포함하지 않고 그저 304 not modified라는 문구를 통해 '아니 안변했음' 이라는 응답을 날린다.

그러면 클라이언트입장에서 변경이 없음이 확인되었으므로 해당 캐시를 다시 사용해도 되는 것이다.

하지만, 해당 방법에도 역시 문제점은 존재한다. 예를들면,

서버 입장에서 동일한 데이터를 가지고 변경점 없이 수정했을 때에 last modified는 변경되었기때문에
서로 대조시에 변경되었다는 상황처럼 되어버려 필요없는 데이터 전송이 일어나게 된다.

또한 날짜에 따른 로직을 사용하기에 나라별로 날짜로직이 다를 수 있어서 이에 대한 처리도 불필요하게 필요해진다.

거기다가, 검증 방식이 단순히 날짜 하나로만 이루어져있기 때문에 보안상의 문제도 발생한다

그래서 해당 방법을 조금 더 보완한 것이 _ETag, If-None-Match_ 이다

예를들어, ETag란 캐시데이터에 임의의 고유한 버전이름을 달아두는것이다.
image가 하나 있다면 여기에 대해서 태그로 랜덤한 스트링값을 달아둔다.
그리고나서 서버측에서 만약 무언가를 수정했을 시에 이 해시를 다시 생성하여서 변경한다.

그리고 클라이언트는 ETag만 헤더에 "If-None-Match"에다가 달아서 보내주어 서로가 달라졌는지를 확인하는 방식이다.
즉, 해당 방식은 캐시의 제어방식을 서버에서 완전하게 통제하는 방식이다.(클라이언트는 해시가 어떻게 생성되는지 모름)

캐시에 관한 일반적인 헤더옵션은 이와같다

1. cache-control : max-age
   = 캐시가 언제까지 유효한지

2. cache-control : no-store
   = 민감한 정보가 많으므로 저장하지 않고 메모리상으로 사용하고 바로 삭제

3. cache-control : public
   = 프록시응답을 하고있을 때에 해당 응답이 public에 저장되어도 됨

4. cache-control : private
   = 프록시 응답은 해당 사용자만 위한것으로, private 캐시형태로 저장되야 함(기본값)

5. cache-control : no-cache
   = 원래 서버로부터 검증이 안되면 캐시하지 않음.

6. cache-control : must-revalidate
   = 캐시 만료후 최초 조회시 서버에게 반드시 검증받아야 함.

> no-cache와 must-revalidate 차이

no-cache는 리버스 프록시 형태라 가정하고 프록시 서버에
no-cache + ETag 형태로 헤더를 달아 요청을 보내면 이 요청대로 프록시 서버에서 서버에게 요청을 다시 날린다
서버는 그 내용을 보고 바뀐게 없으면 304 코드를 응답한다

만약, 원 서버에 프록시 서버가 접근을 못할 경우 설정에 따라 에러메세지를 내거나 아니면 200번대 ok 를 줌으로서 기존에 내용이라도 그대로 사용하도록 처리한다

하지만 must-revalidate은 원 서버에 접근을 하지 못했다면 504 gateway timeout 오류를 내보낸다.

# 2. 프록시

프록시란, 클라이언트가 다른 네트워크 서비스에 간접적으로 접속하게 할 수 있도록 하는 통신망을 말한다.

즉, 클라이언트가 바로 서버에 접속하기보다 연결을 대행해주는 프록시서버에 연결되고, 프록시서버는 서버와 인터넷을 통해 연결되면서 서로 대화하는 방식이다.

간접적인 접속이라는 이점덕택에 보안, 캐싱, 트래픽 분산등을 관리하는 중간경로로서의 역할을 할 수가 있다.

예를들어 (CDN을 생각해보자)

한국에서 미국의 서버에 있는 데이터를 요청하는 상황이라고 보자. 아무래도 한국에 있는 서버에서 얻는거보다는 시간이 오랙 걸릴것이다
그렇다면 상식적으로 한국에 static 데이터를 캐시형태로 복사해서 저장하고 있는 서버를 두는 것이
속도적인 측면에서 더욱 빠르고 안정적일것이다.

이때 클라이언트가 프록시 서버에서 가져오는 데이터를 private 캐시라고 하고, 프록시 서버에 있는 데이터를 public 캐시라고 부른다.

이때 프록시 서버의 행동형태에 따라 크게 _forward proxy_, _reverse proxy_ 로 나뉜다

## Forward proxy

---

클라이언트가 서버에 요청을 전달하고 프록시 서버는 그 요청에 따라 자신이 가지고 있는 캐시를 전달해주거나 없다면 프록시 서버가 인터넷을 통해 연결된 서버에게 요청을 날려서 받아오는 그 값을 전달해주는 방식이다.

즉, forward proxy는 클라이언트가 요청하는 end point가 실제 그 서버 도메인이다. 마치 중계인처럼 서버에게 요청했더니 프록시 서버가 해당 처리를 해주는것과 같은 개념이다

## Reverse proxy

---

반대로 Reverse proxy는 요청 자체의 end point가 프록시 서버로 이어져있다. 즉, 클라이언트 입장에서는 실제 서버의 정보는 전혀 알 수 없고 마치 프록시 서버가 실제 서버의 대리자 역할을 하는 것과 같다.
