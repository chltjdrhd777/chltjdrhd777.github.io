# ** UseEffect와 useCallback이 하는 행동의 연관관계성**

![javasciprt](https://img.shields.io/badge/javascript-up%20to%20date-yellow)

![typescript](https://img.shields.io/badge/typescript-up%20to%20date-blue)

---

## 1 useEffect

리엑트를 조금이라도 사용해봤다면 이 이름을 들어본 적이 있을 것이다. 나 역시 수도없이 써보고 이미 기능을 잘 안다고 자부하고 있었는데, 그럴 때마다 `응 자만하지마` 라며 깨달음을 주는 리엑트에게 감사한다.

여튼 각설하고, useEffect는 다들 알다시피 sideEffect를 최소화하기 위한 리엑트적 장치다. sideEffect는 말 그대로, 순수 함수적인 행동을 못하게 만드는 주변적 행동(함수 바깥의 상태를 변경시키든가, 변경이 막 되는 상태를 함수 내부에서 이용한다든가) 하는 상황들을 의미하는데, useEffect가 이것을 어떻게 처리해주는가에 대한 고민을 좀 더 해봐야했다.

일반적으로 리엑트가 함수 컴포넌트기준 "함수" 를 리 랜더링하는 기준은

- 1. prop 값이 바뀌었음
- 2. 상태 값이 바뀌었음

인데, useEffect도 거창해보여도 역시 함수고, 함수가 함수 내부에서 호출되어 실행된다는 것은 스텍에 쌓여서 실행된다는 소리다. 그러니 useEffect가 마치 특별하게 컴포넌트가 리랜더링되면 실행된다 라기보다는 그냥 자바스크립트 그 자체의 의미로 받아들이면된다.

> 리렌더링 = 함수 컴포넌트의 재호출 = 함수를 재실행한다는거
> 그러니까 그 안에서 호출되고 있는 useEffect는 당연히 재실행될수밖에없다.

근데 이 useEffect가 호출이 되면 하는 행동이 좀 특이하다
_useEffect는 호출을 하면, 자신이 받아들이고 있는 콜백을 자신들의 reactDOM 환경에 등록하고, 실행한다._

근데 만약 이게 끝이면, 솔직히 그냥 일반 함수 호출을 하고있는것과 다를 바가 없을것이다.

근데 useEffect의 가장 특별한 부분은 두번째 인자, dependency에 있다.

이 dependency가 만약 빈배열로 존재하게 된다면, 설령 전체 함수 컴포넌트가 리랜더링 되더라도 등록해놨던 함수를 실행하지 않는다. (실행되는 때는 최초로 읽어지는 때일 뿐이다).

그리고 이 안에 값(순수함수를 깨트리게 되는 변이가 지속되는 값)이 존재한다면 그 때마다 useEffect는 등록시킨 함수를 실행시켜서 내부값을 변경시킬 수 있다. 그리고 이는 마찬가지로, 리 랜더링을 촉발시킨다.

즉, 예를들자면 어떤 버튼을 클릭하였을 때에 그 버튼이 상태를 변경시키고, 그 값의 변화에 따라 useEffect가 등록해둔 콜백함수의 실행이 촉발된다면,

> 그 콜백함수의 내부에서 만약 상태의 변화가 일어나는 게 없다면 리 랜더링은 되지 않는다

하지만 그 함수의 내부에 상태의 변화가 일어날 요소가 존재한다면, 리 렌더링이 실행되므로써 화면에 보이는 것이 변경되는 것이다.

즉, 요약하자면 내가 보는 useEffect의 움직임 원리는 이렇다.

1. useEffect는 단순하게 생각하면 함수다
2. 자바스크립트가 파일을 읽으면, 그냥 원래 그러하듯 useEffect라는 함수를 실행시켜 콜스텍에 저장한다.
3. 그리고 나서 호출을 하면 useEffect는 받은 콜백을 특정 환경에 저장한 후, 그 콜백을 실행시킨다. 또한 두번째 인자가 존재할경우, 그 인자를 특정 환경에 저장해둔다.
4. _여기서 중요한 것은 리 렌더링의 타이밍인데, 만약 useEffect가 받는 콜백이 상태를 변경하는 내용이 있을 경우, useEFfect에서 일단 멈추고 다시 변경된 값으로 재 패인트하여 읽어내는것이 아닌, 자바스크립트 파일을 처음부터 끝까지 다 실행한 후, 그 다음 useEffect의 상태변화 행동에 의한 리랜더링을 진행하는 것으로 보인다.(콘솔로 찍히는 활동을 바라보면 그럴 가능성이 높다). 따라서, 이러한 이유때문에 useMemo나 useCallback 과 같은 훅이 존재하는 것이다. 기존에 있던 내용을 또다시 리랜더링해서 반복해서 평가해야한다면, 그것은 상당한 낭비라고 보여질 수 있다_

5. 여튼, 위에서 언급하였듯 useEffect로 인해 등록된 두번째 종속성 배열은 계속해서 해당 식별자에 대항하는 상태를 추적하고 있다가, 이것이 변화를 겪게 된다면(이때 같지 않은지의 평가는 비교성능의 원활함을 위해 얕은비교가 일어나고 있다. 이건 리덕스도 마찬가지로 하고있는 행동이긴 한데, 만약 상태가 객체와 같은 레퍼런스 주소인데 그 매우 깊은 아래에서 변하는것까지 다 평가하려면 코스트가 상당히 그지같다. 그래서 setState과 같은 함수는 아예 state 자체를 변경시켜버리고, 이에 따라 랜더링 시점을 결정하는 것이다. 어썸하지 않은가.)
