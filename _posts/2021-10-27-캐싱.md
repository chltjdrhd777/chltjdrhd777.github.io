# **캐시의 원리**

![javasciprt](https://img.shields.io/badge/javascript-up%20to%20date-yellow)

![typescript](https://img.shields.io/badge/typescript-up%20to%20date-blue)

---

## 캐시는 네트워크 요청을 조금이라도 줄여보기 위한 필사의 노력이다

예를들어, 어느 서버에서 이미지를 다운받는다고 생각하자

네트워크 세계에서 이미지와 같이 나름 상대적으로 전송 단위가 큰 물체들을 네트워크로 매번 새로운 페이지로 갈 때마다 요청해서 받아오는건 좀 낭비다

> ex <img src="서버주소"> 를 생각해보자. 라우팅을 통해 페이지를 이동했는데 저 코드를 읽어서 서버에 또 요청하는건 상당히 비효율적이지 않겠는가(내용물이 변하지 않았으면)

그래서 나온 기술이 캐싱이다

캐싱은 서버에서 이미지와 같은 자원을 전달받을 때, 서버에서 마치 쿠키마냥 헤더에 cache control이나 eTag 와 같은 정보를 같이 전달하여 브라우저 프로그램에 이 내용을 캐시로 저장하라는 명령을 내린다

자 그러면 브라우저 입장에선 만약에 해당 서버 경로로 이미지 자원을 요청하려고 시도할때, 만약 캐시에 내용물이 존재한다면 서버에 요청을 보내지 않고 그 내용을 그대로 쓸 수 있다. 이게 바로 캐시의 큰 장점이다

캐시에 대한 서버의 응답으로 사용할 수 있는 것은
일단 공통적으로는 캐시의 유효시간을 나타내는 max-age(초) 가 있다.
그 외에 이제 변동을 검사하는 방법으로 서버가 헤더에 붙여서 전달하는 게 있는데

-날짜를 기반으로 하는 "Last-modified" -특수 해싱 태그를 이용하는 "Etag"

날짜를 기반으로 하는 Last modified 정보는 브라우저가 가지고 있다가, 만약 캐시의 max-age가 끝나게 된다면 서버에 request 객체를 날릴 때 헤더에 "If-modifed-since" 옵션으로 날짜를 전달하여 서버입장에서 비교하게 하였다.

만약 변동이 없다면 서버는 데이터를 바디에 넣지 않고 그냥 응답 코드로 304 not modified를 전달하여 해당 캐시의 max-age를 초기화시키도록 하는 방식을 썼으나,

예를들어 내용물은 변하지 않았는데 그냥 단순 저장으로 인해 서버쪽에서 last-modified가 바뀌어있을 경우,

날짜를 비교하면 서로 다른 값이라고 인식하고 데이터를 보내는 문제가 있었다

그래서 이것을 보완하기 위해 날짜 대신에 "Etag"를 보낸다

이 해싱값은 날짜랑 하는 역할이 똑같다. 그냥 날짜대신에 특수하게 해싱된 Etag를 헤더로 보낸다는것이 달라졌을 뿐이다.

만약 브라우저가 캐싱 파일을 봤을 때 max-age가 만료되었다면,
request 헤더에 "If-none-match" 라고 하는, 이 해싱 태그가 일치 안하니? 하는 헤더를 서버에 보내주고, 서버는 그 해싱값을 보고 변경이 없다면 304 not modified를 응답으로 전달하는 것이다.

---

# proxy

참고로, 이 캐싱 기법이 극대화 된 것이 바로 프록시이다

예를들어, 우리가 미국 서버에 있는 자원을 요청하려고 리퀘스트를 날린다고 치자.

지구 반대편에 있는 땅덩어리에 요청을 보내는게 빠를 리가 없다.

그러므로, 이 캐싱기법을 이용한 대리인 서버를 각 나라별로 분산하여 두는 것이다.

만약 요청을 날리게 된다면 이 프록시 서버를 통해 간접적으로 자원을 요청하고 응답을 받는 형식을 취한다

프록시 서버에 대한 캐시 헤더응답으로 올 수 있는 것은 대표적으로 이와같다

1. cache-control: private
   = 해당 자원은 클라이언트 너만 저장하세요(프록시 서버에 저장이 안되게 할겁니다)

2. cache-control: public
   = 해당 자원은 프록시 서버도 갖고있을 수 있어요

3. cache-control: s-maxage
   = 프록시 자원용 max-age

4. cache-control: no-store
   = 캐시로 저장하지 마세요

5. cache-control: no-cahe
   = 캐시 만료되어서 재요청할때 원래 서버한테 허락받고 하세요
   (프록시 서버에서 임의로 하지 말고 프록시 서버를 경유하여 실제 서버에게 Etag를 전송하여 응답을 다시 프록시를 통해 대리하여 받음)
   (no-cache는 만약 응답을 받는것에 실패하면 일단 프록시서버가 200번대 요청이라도 해준다)

6. cache-control: must-revalidate
   = 캐시가 만료되었을 때 프록시 서버를 경유하여 원래 서버에서 캐시관련 응답을 다시 받아야 하는 것은 똑같은데, 만약 응답에 받는것에 실패하면 504 gateway timeout을 받게된다.(만약, 통장 잔고를 확인하였는데 응답 실패했다고 200번대로 이전에 기록을 다시쓰게한다면 문제이므로 이런 비슷한 케이스에서 사용됨)
