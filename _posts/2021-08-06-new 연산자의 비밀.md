# **new는 뭘까**

![javasciprt](https://img.shields.io/badge/javascript-up%20to%20date-yellow)

![typescript](https://img.shields.io/badge/typescript-up%20to%20date-blue)

---

보통 객체지향적인 개발을 진행할 경우, 생성자 함수를 만들어서 new를 통해 호출하는 경우와 es6부터 도입된 클래스를 이용하는 방식이 대부분일 것이다.

그런데, 어차피 class가 함수형 생성자의 형태를 살짝 변형해서 응용하고 _(예를들어, class 함수 내부에 constructor을 명시적으로 정의한다든가, 함수형에서는 프로토타입에 메소드를 집어넣으려면 함수 외부에서 function.prototype.method = ~~~ 식으로 복잡하게 해야 하는 반면, 클래스에서는 그냥 간단하게 constructor 바깥에서 정의하는 메소드형식의 함수를 프로토타입의 메소드로 넣어주는 등)_

각종 특이 기능들이 존재한다고 한들(typescript로 따지면 private, protected, readonly 등등)

기본은 결국 생성자 함수고, 이 생성자 함수가 객체를 생성할 때 있어서 작동하기 위한 첫 시작점인 new 연산자는 아주 큰 역할을 한다고 할 수 있다.

그런데, 이것이 실행되는 과정을 따지고 보면 의외로 심오하다

```js
만약, 생성자 함수 앞에 new가 붙게 된다면 ECMAscript 의 기술내용에 따른 자바스크립트 해석에 있어 임의로 정의되는 빈 객체 {} 를 설정하고, 이 객체에 함수가 this를 바인딩한다는 것은 익숙할 것이다.

그런데, 그것보다 더 먼저하는 행동이 있다.

그것은 바로 "얘가 진짜 생성자로 쓸 수 있니?" 하고 물어보는 과정이다

내부슬롯 [[call]], [[construct]]의 정의내용에 따라, 해당 construct 슬롯이 존재해야만 생성자로서 쓰일 수 있다.

그런데 문제는 생성자 함수로 쓰고자 해서 디자인한 함수를 가지고 그냥 호출을 하는 상황이 문제다

예를들어

function Test (name) {
    this.name = name;
}

이렇게 정의한 Test 함수는 언제든지 new를 통해 객체를 생성할 수 있다.

근데 문제는 이 내부에 정의된 것에는 슬롯에 call 이 존재하기 때문에, 언제든지 그냥 일반 함수처럼 호출할 수 있다는 것이 문제다

즉, Test("hello this is error") 하고 호출을 하게 된다면,

함수는 렉시컬 스코프를 따른다는 것을 인지했을 때, 해당 함수가 만약 전역적으로 설정되어 있다면 사실상 Window.Test("hello this is error") 하고 호출하는 것과 같다는 것을 알 수 있다.

this 의 정의방식을 간단하게 설명하자면

1. 일반 함수 선언식은 this를 따를 때에 new가 있으면 임시로 토스되는 객체의 메모리주소와 바인딩, 그리고 특정 객체의 메소드 처럼 존재할경우, 호출당시의 . 앞에 있는 호출자를 뜻한다.

2. 만약 화살표함수이거나, es6에 도입된 메소드의 형태를 띄고 있다면 this는 마치 변수를 사용하듯 상위 스코프에서 정의된 this를 가져와서 활용한다.

여튼, 그렇기 때문에 일반함수처럼 Test를 실행하게 된다면, 그 내부에서 가리키는 this 는 Window가 되어버리기 때문에, 전역객체에다가 name = "hello this is error" 을 설정하는 것과 같다.

이를 막기 위한 방법으로는 새로 도입된 new.target을 이용하면 된다

ex

function Test (name){
    this.name = name;

    if(!new.target){
        return new Test(name); // new 없이 호출했으면 new를 붙여서 재호출한다.
    }
}
```
